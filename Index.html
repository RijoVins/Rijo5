<html>
    <head>
<style>
    div{
        margin-left: 40%;
    }
    body{
        font-size: x-large;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    img{
        width:700px;
        height:300px;
        margin-left: 10%;
    }

</style>
    </head>
    <body>
        <h1>
            Local Search:
        </h1>
        <p>
            Local search algorithms are essential tools in artificial intelligence and optimization, employed to find high-quality solutions in large and complex problem spaces. Key algorithms include Hill-Climbing Search, Simulated Annealing, Local Beam Search, Genetic Algorithms, and Tabu Search.


        </p>
        <img src="images/img.png">
        <h3>Types Of Local Search:</h3>
        <ul>
            <li> Hill-Climbing Search Algorithm
            </li>
            <li>Simulated Annealing</li>
            <li> Local Beam Search</li>
            <li>Genetic Algorithms</li>
            <li>Tabu Search</li>

        </ul>
        <h3>1. Hill-Climbing Search Algorithm
        </h3>
        <p>
            Hill-Climbing is a straightforward local search algorithm that iteratively moves towards better solutions. It is often used for optimization problems where the goal is to find the peak of a landscape, represented by an objective function.


        </p>
        <h4>Process:
        </h4>
        <ul>
            <li>Start: Begin with an initial solution.
            </li>
            <li>Evaluate: Assess the neighboring solutions.
            </li>
            <li>Move: Transition to the neighbor with the highest objective function value if it improves the current solution.
            </li>
            <li>Repeat: Continue this process until no better neighboring solution exists.
            </li>

        </ul>
        <h4>Types:</h4>
    <ul>
        <li>Simple Hill-Climbing: Chooses the first neighbor that improves the solution.
        </li>
        <li>Steepest-Ascent Hill-Climbing: Evaluates all neighbors and selects the best one.
        </li>
        <li>Stochastic Hill-Climbing: Randomly selects neighbors to explore.
        </li>

    </ul>
    <h4>
        Pros:

    </h4>
<ul>
    <li>Easy to implement.
    </li>
    <li>Works well in small or smooth search spaces.
    </li>

</ul>
<h4>
Cons:
</h4>
<ul>
    <li>May get stuck in local optima.
    </li>
    <li>Limited exploration of the search space.
    </li>

</ul>
<h3>
    2. Simulated Annealing

</h3>
<p>
    Simulated Annealing is inspired by the annealing process in metallurgy, where materials are heated and then gradually cooled to remove defects. It allows for occasional moves to worse solutions to escape local optima, with the probability of such moves decreasing over time.


</p>
<h4>Process:
</h4>
<ul>
    <li>Start: Begin with an initial solution and an initial temperature.
    </li>
    <li>Move: Transition to a neighboring solution with a certain probability.
    </li>
    <li>Cooling Schedule: Gradually reduce the temperature according to a predefined schedule.
    </li>
    <li>Probability Function: Accept worse solutions with a probability that decreases as the temperature decreases.
    </li>

</ul>
<h4>
    Pros:

</h4>
<ul>
    <li>Can escape local optima due to probabilistic acceptance of worse solutions.
    </li>
    <li>Flexible in exploring the solution space.
    </li>
   </ul>

</ul>
<h4>
    Cons:
    </h4>
<ul>
    <li>Requires careful tuning of parameters like temperature and cooling schedule.
    </li>
    <li>Computationally expensive due to repeated evaluations.
    </li>
  
</ul>

<h3>3. Local Beam Search
</h3>
<p>
    Local Beam Search is a variant of local search that maintains multiple states (or beams) at each level of the search. It explores multiple paths simultaneously, aiming to increase the likelihood of finding a good solution.


</p>
<h4>Process:</h4>
<ul>
    <li>Start: Begin with a set of initial solutions (beams).
    </li>
    <li>Generate: Expand all current solutions to their neighbors.
    </li>
    <li>Select: Choose a subset of the best neighbors to form the new beams.
    </li>
    <li>Repeat: Continue expanding and selecting until a solution meets the criteria or a stopping condition is reached.
    </li>
</ul>
<h4>
    Pros:

</h4>
<ul>
    <li>More likely to find a good solution than single-state local search.
    </li>
    <li>Reduces the risk of getting stuck in local optima.
    </li>
   
</ul>
<h4>
    Cons:
    </h4>
<ul>
    <li>Requires managing multiple states and their neighbors.
    </li>
    <li>Computationally intensive as the number of beams increases.
    </li>
  
</ul>

<h3>
    4. Genetic Algorithms

</h3>
<p>
    Genetic Algorithms (GAs) are inspired by the process of natural selection and evolution. They work with a population of solutions and evolve them over time using genetic operators like selection, crossover, and mutation.


</p>

<h4>Process:</h4>
<ul>
    <li>Initialize: Start with a population of random solutions.
    </li>
    <li>Evaluate: Assess the fitness of each solution.
    </li>
    <li>Select: Choose the best solutions for reproduction based on their fitness.
    </li>
    <li>Replace: Form a new population by selecting which solutions to keep.
    </li>
</ul>
<h4>
    Pros:

</h4>
<ul>
    <li>Can explore a broad solution space and find high-quality solutions.
    </li>
    <li>Suitable for complex problems with large search spaces.
    </li>
  
</ul>
<h4>
    Cons:
    </h4>
<ul>
    <li>Computationally expensive due to the need for evaluating many solutions.
    </li>
    <li>Requires tuning of various parameters like population size and mutation rate.
    </li>
  
</ul>
<h3>
    5. Tabu Search

</h3>
<p>
    Tabu Search enhances local search by using a memory structure called the tabu list to avoid revisiting previously explored solutions. This helps to prevent cycling back to local optima and encourages exploration of new areas.


</p>
<h4>Process:</h4>

<ul>
    <li>Start: Begin with an initial solution and initialize the tabu list.
    </li>
    <li>Move: Transition to a neighboring solution while considering the tabu list.
    </li>
    <li>Update: Add the current solution to the tabu list and potentially remove older entries.
    </li>
    <li>Aspiration Criteria: Allow moves that lead to better solutions even if they are in the tabu list.
    </li>
</ul>
<ul>
    <li>Reduces the chance of getting stuck in local optima.
    </li>
    <li>Effective in exploring large and complex search spaces.
    </li>
   
</ul>
<ul>
    <li>Requires careful management of the tabu list and aspiration criteria.
    </li>
    <li>Computational complexity can be high.
    </li>
   
</ul>

<p>
    Local search algorithms are powerful tools for solving optimization problems, each with its strengths and weaknesses. Hill-Climbing is simple and easy to understand but can be limited in its exploration. Simulated Annealing introduces randomness to escape local optima, while Local Beam Search leverages multiple paths to find better solutions. Genetic Algorithms offer a broad exploration strategy through evolution, and Tabu Search uses memory to enhance exploration and avoid cycles. Understanding these algorithms helps in selecting the right approach for a given problem and optimizing the solution effectively.


</p>
<div>
<h1>
    Thank You!
</h1></div>
</body>
</html>